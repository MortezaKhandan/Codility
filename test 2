You are given a string S of length N which encodes a non-
negative number V in a binary form. Two types of operations
may be performed on it to modify its value:

• if V is odd, subtract 1 from it;
• if V is even, divide it by 2.
These operations are performed until the value of V becomes
0.
For example, if string S = "011100", its value V initially is 28.
The value of V would change as follows:
• V = 28, which is even: divide by 2 to obtain 14;
• V = 14, which is even: divide by 2 to obtain 7;
• V = 7, which is odd: subtract 1 to obtain 6;
• V = 6, which is even: divide by 2 to obtain 3;
• V = 3, which is odd: subtract 1 to obtain 2;
• V = 2, which is even: divide by 2 to obtain 1;
• V = 1, which is odd: subtract 1 to obtain 0.
Seven operations were required to reduce the value of V to 0.
Write a function:
int solution(string &S);
that, given a string S consisting of N characters containing a
binary representation of the initial value V, returns the number
of operations after which its value will become 0.

Examples:
1. Given S = "011100", the function should return 7. String S
represents the number 28, which becomes 0 after seven
operations, as explained above.
2. Given S = "111", the function should return 5. String S
encodes the number V = 7. Its value will change over the
following five operations:
• V = 7, which is odd: subtract 1 to obtain 6;
• V = 6, which is even: divide by 2 to obtain 3;
• V = 3, which is odd: subtract 1 to obtain 2;
• V = 2, which is even: divide by 2 to obtain 1;
• V = 1, which is odd: subtract 1 to obtain 0.
3. Given S = "1111010101111", the function should return 22.
4. Given string S consisting of "1" repeated 400,000 times, the
function should return 799,999.
Write an efficient algorithm for the following assumptions:
• string S is made only of the characters "o"
and/or "1";
• N, which is the length of string S, is an integer
within the range [1...1,000,000];
• the binary representation is big-endian, i.e. the
first character of string S corresponds to the
most significant bit;
• the binary representation may contain leading
zeros.


int solution(string &S) {
    int count = 0;
    int num = 0;
    for (int i = 0; i < S.length(); i++) {
        if (S[i] == '1') {
            num += (1 << (S.length() - i - 1));
        }
    }
    while (num > 0) {
        if (num % 2 == 0) {
            num /= 2;
        } else {
            num--;
        }
        count++;
    }
    return count;
}


int main()
{
    // vector<int> A = {0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0};
    // cout << solution(A) << endl; // Output: 3

string str1="011100"; // 7
string str2="111"; // 5
string str3="1111010101111"; // 22
    // printf("\n");
    printf("%d", solution(str1));
    printf("\n");
    printf("%d", solution(str2));
    printf("\n");
    printf("%d", solution(str3));
    printf("\n");
    return 0;
}